CREATE TABLE IF NOT EXISTS birds (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    common_name text NOT NULL,
    scientific_name text,
    static_image_name text,
    family text,
    order_name text,
    description_text text,
    conservation_status text,
    migration_strategy text,
    hemisphere text,
    valid_locations jsonb DEFAULT '[]'::jsonb,
    valid_months jsonb DEFAULT '[]'::jsonb,
    shape_id text,
    size_category integer,
    field_mark_data jsonb DEFAULT '{}'::jsonb
);

CREATE TABLE IF NOT EXISTS watchlists (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    type text DEFAULT 'custom' CHECK (type IN ('custom', 'shared', 'my_watchlist')),
    title text,
    location text,
    location_display_name text,
    start_date timestamptz,
    end_date timestamptz,
    observed_count integer DEFAULT 0,
    species_count integer DEFAULT 0,
    cover_image_path text,
    species_rule_enabled boolean DEFAULT false,
    species_rule_shape_id text,
    location_rule_enabled boolean DEFAULT false,
    location_rule_lat double precision,
    location_rule_lon double precision,
    location_rule_radius_km double precision DEFAULT 50.0,
    location_rule_display_name text,
    date_rule_enabled boolean DEFAULT false,
    date_rule_start_date timestamptz,
    date_rule_end_date timestamptz,
    row_version integer DEFAULT 0,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz
);

CREATE TABLE IF NOT EXISTS watchlist_entries (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    watchlist_id uuid NOT NULL REFERENCES watchlists(id) ON DELETE CASCADE,
    bird_id uuid REFERENCES birds(id) ON DELETE SET NULL,
    nickname text,
    status text NOT NULL DEFAULT 'to_observe' CHECK (status IN ('to_observe', 'observed')),
    notes text,
    added_date timestamptz DEFAULT now(),
    observation_date timestamptz,
    to_observe_start_date timestamptz,
    to_observe_end_date timestamptz,
    observed_by text,
    lat double precision,
    lon double precision,
    location_display_name text,
    priority integer DEFAULT 0,
    notify_upcoming boolean DEFAULT false,
    target_date_range text,
    row_version integer DEFAULT 0,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz
);

CREATE TABLE IF NOT EXISTS watchlist_rules (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    watchlist_id uuid NOT NULL REFERENCES watchlists(id) ON DELETE CASCADE,
    rule_type text NOT NULL CHECK (rule_type IN ('location', 'date_range', 'species_family', 'migration_pattern')),
    parameters_json text NOT NULL DEFAULT '{}',
    is_active boolean DEFAULT true,
    priority integer DEFAULT 0,
    row_version integer DEFAULT 0,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz
);

CREATE TABLE IF NOT EXISTS watchlist_shares (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    watchlist_id uuid NOT NULL REFERENCES watchlists(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    permission text DEFAULT 'view' CHECK (permission IN ('view', 'edit', 'admin')),
    shared_at timestamptz DEFAULT now(),
    shared_by_user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    UNIQUE(watchlist_id, user_id)
);

CREATE TABLE IF NOT EXISTS observed_bird_photos (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    watchlist_entry_id uuid NOT NULL REFERENCES watchlist_entries(id) ON DELETE CASCADE,
    image_path text NOT NULL,
    storage_url text,
    is_uploaded boolean DEFAULT false,
    row_version integer DEFAULT 0,
    last_synced_at timestamptz,
    captured_at timestamptz,
    uploaded_at timestamptz,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz
);

CREATE INDEX idx_observed_bird_photos_entry_id ON observed_bird_photos(watchlist_entry_id);

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- Apply triggers to all tables with updated_at
CREATE TRIGGER update_watchlists_updated_at
    BEFORE UPDATE ON watchlists
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_watchlist_entries_updated_at
    BEFORE UPDATE ON watchlist_entries
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_watchlist_rules_updated_at
    BEFORE UPDATE ON watchlist_rules
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_observed_bird_photos_updated_at
    BEFORE UPDATE ON observed_bird_photos
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE birds ENABLE ROW LEVEL SECURITY;
ALTER TABLE watchlists ENABLE ROW LEVEL SECURITY;
ALTER TABLE watchlist_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE watchlist_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE watchlist_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE observed_bird_photos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own profile"
    ON users FOR SELECT
    USING (auth.uid() = id);
-- Users can update their own profile
CREATE POLICY "Users can update own profile"
    ON users FOR UPDATE
    USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

CREATE POLICY "Authenticated users can read birds"
    ON birds FOR SELECT
    TO authenticated
    USING (true);
-- Only service role can insert/update/delete birds (seeding)
CREATE POLICY "Service role can manage birds"
    ON birds FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- Users can read their own watchlists
CREATE POLICY "Users can read own watchlists"
    ON watchlists FOR SELECT
    TO authenticated
    USING (
        owner_id = auth.uid() 
        OR id IN (
            SELECT watchlist_id 
            FROM watchlist_shares 
            WHERE user_id = auth.uid()
        )
    );
-- Users can insert their own watchlists
CREATE POLICY "Users can create watchlists"
    ON watchlists FOR INSERT
    TO authenticated
    WITH CHECK (
        owner_id = auth.uid() 
        OR owner_id IS NULL
    );
-- Users can update their own watchlists
CREATE POLICY "Users can update own watchlists"
    ON watchlists FOR UPDATE
    TO authenticated
    USING (
        owner_id = auth.uid()
        OR id IN (
            SELECT ws.watchlist_id 
            FROM watchlist_shares ws
            WHERE ws.user_id = auth.uid()
            AND ws.permission IN ('edit', 'admin')
        )
    )
    WITH CHECK (
        owner_id = auth.uid()
        OR owner_id IS NULL
    );
-- Users can delete their own watchlists (owner only, not shared users)
CREATE POLICY "Owners can delete watchlists"
    ON watchlists FOR DELETE
    TO authenticated
    USING (owner_id = auth.uid());
-- ============================================================================
-- WATCHLIST ENTRIES TABLE POLICIES
-- ============================================================================
-- Users can read entries from their watchlists or shared watchlists
CREATE POLICY "Users can read own entries"
    ON watchlist_entries FOR SELECT
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
            OR id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
            )
        )
    );
-- Users can insert entries into their watchlists
CREATE POLICY "Users can create entries"
    ON watchlist_entries FOR INSERT
    TO authenticated
    WITH CHECK (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
            OR id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
                AND permission IN ('edit', 'admin')
            )
        )
    );
-- Users can update entries in their watchlists
CREATE POLICY "Users can update own entries"
    ON watchlist_entries FOR UPDATE
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
            OR id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
                AND permission IN ('edit', 'admin')
            )
        )
    );
-- Users can delete entries from their watchlists
CREATE POLICY "Users can delete own entries"
    ON watchlist_entries FOR DELETE
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
            OR id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
                AND permission IN ('edit', 'admin')
            )
        )
    );
-- ============================================================================
-- WATCHLIST RULES TABLE POLICIES
-- ============================================================================
-- Users can read rules from their watchlists
CREATE POLICY "Users can read own rules"
    ON watchlist_rules FOR SELECT
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
            OR id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
            )
        )
    );
-- Users can manage rules in their watchlists
CREATE POLICY "Users can manage own rules"
    ON watchlist_rules FOR ALL
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
            OR id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
                AND permission IN ('edit', 'admin')
            )
        )
    );
-- ============================================================================
-- WATCHLIST SHARES TABLE POLICIES
-- ============================================================================
-- Users can read shares for their watchlists
CREATE POLICY "Users can read own shares"
    ON watchlist_shares FOR SELECT
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
        )
        OR user_id = auth.uid()
    );
-- Owners can share their watchlists
CREATE POLICY "Owners can share watchlists"
    ON watchlist_shares FOR INSERT
    TO authenticated
    WITH CHECK (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
        )
    );
-- Owners can update/remove shares
CREATE POLICY "Owners can manage shares"
    ON watchlist_shares FOR UPDATE
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
        )
    );
-- Owners can delete shares
CREATE POLICY "Owners can delete shares"
    ON watchlist_shares FOR DELETE
    TO authenticated
    USING (
        watchlist_id IN (
            SELECT id FROM watchlists 
            WHERE owner_id = auth.uid()
        )
    );
-- ============================================================================
-- OBSERVED BIRD PHOTOS TABLE POLICIES
-- ============================================================================
-- Users can read photos from their watchlists
CREATE POLICY "Users can read own photos"
    ON observed_bird_photos FOR SELECT
    TO authenticated
    USING (
        watchlist_entry_id IN (
            SELECT we.id FROM watchlist_entries we
            JOIN watchlists w ON w.id = we.watchlist_id
            WHERE w.owner_id = auth.uid()
            OR w.id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
            )
        )
    );
-- Users can manage photos in their watchlists
CREATE POLICY "Users can manage own photos"
    ON observed_bird_photos FOR ALL
    TO authenticated
    USING (
        watchlist_entry_id IN (
            SELECT we.id FROM watchlist_entries we
            JOIN watchlists w ON w.id = we.watchlist_id
            WHERE w.owner_id = auth.uid()
            OR w.id IN (
                SELECT watchlist_id 
                FROM watchlist_shares 
                WHERE user_id = auth.uid()
                AND permission IN ('edit', 'admin')
            )
        )
    );
-- ============================================================================
-- SUPPLEMENTARY FUNCTIONS
-- ============================================================================
-- Function to get all accessible watchlist IDs for a user
CREATE OR REPLACE FUNCTION get_accessible_watchlist_ids(user_uuid uuid)
RETURNS TABLE(id uuid) AS $$
BEGIN
    RETURN QUERY
    SELECT w.id FROM watchlists w
    WHERE w.owner_id = user_uuid
    UNION
    SELECT ws.watchlist_id FROM watchlist_shares ws
    WHERE ws.user_id = user_uuid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Function to check if user can edit a watchlist
CREATE OR REPLACE FUNCTION can_user_edit_watchlist(watchlist_uuid uuid, user_uuid uuid)
RETURNS boolean AS $$
DECLARE
    owner uuid;
    permission text;
BEGIN
    -- Check if user owns the watchlist
    SELECT w.owner_id INTO owner
    FROM watchlists w
    WHERE w.id = watchlist_uuid;
    
    IF owner = user_uuid THEN
        RETURN true;
    END IF;
    
    -- Check if user has edit permission via shares
    SELECT ws.permission INTO permission
    FROM watchlist_shares ws
    WHERE ws.watchlist_id = watchlist_uuid
    AND ws.user_id = user_uuid
    AND ws.permission IN ('edit', 'admin');
    
    RETURN permission IS NOT NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
---