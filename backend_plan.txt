Now I have full context. Here's the Updated Plan addressing all gaps:
---
Updated Plan: Watchlist + Home + Identification → Supabase + PostGIS
1. Auth Replacement Plan (Keychain → Supabase Auth)
Current System
| Component | Current |
|-----------|---------|
| Email/password | KeychainManager (save/retrieve) |
| Login | Check keychain, create User (no UUID), save to UserSession |
| SignUp | Save to Keychain |
| Session cache | UserSession stores encoded User in UserDefaults (NOT Keychain) |
| User model | name, gender, email, profilePhoto (NO UUID!) |
| Hardcoded owner_id | UUID(uuidString: "00000000-0000-0000-0000-000000000001")! |
Target System
| Component | Target |
|-----------|--------|
| All auth | Supabase Auth (email/password + Google) |
| User model | id (UUID from Supabase auth.uid()), name, gender, email, profilePhoto |
| Session | Supabase session tokens persisted in iOS Keychain (privacy-first), restored on app launch, updated on auth state changes |
| User profile cache | UserSession may cache non-sensitive user profile in UserDefaults; auth tokens never stored in UserDefaults |
| owner_id | Logged in: UserSession.shared.currentUser?.id, Logged out: nil (pending-owner local state) |
| Guest watchlist behavior | Persist locally across app restarts before login; on login, adopt to current user and sync |
---
2. Files to Modify/Create
Auth Replacement (NEW)
| # | File | Action | Purpose |
|---|------|--------|---------|
| A1 | User.swift | MODIFY | Add id: UUID field |
| A2 | SupabaseAuthService.swift | CREATE | Replace KeychainManager + GoogleSignIn with Supabase Auth |
| A3 | UserSyncService.swift | CREATE | Sync User record to users table |
| A4 | UserSession.swift | MODIFY | Add currentUserId, load from Supabase session |
| A5 | LoginViewController.swift | MODIFY | Use SupabaseAuthService instead of KeychainManager |
| A6 | SignUpViewController.swift | MODIFY | Use SupabaseAuthService.signUp |
| A7 | StartViewController.swift | MODIFY | Use SupabaseAuthService.signInWithGoogle |
| A8 | SceneDelegate.swift | MODIFY | Check Supabase session, remove auth bypass |
Sync + Supabase (NEW)
| # | File | Action | Purpose |
|---|------|--------|---------|
| S1 | SupabaseClient.swift | CREATE | Supabase config (URL, anon key) |
| S2 | SyncModels.swift | CREATE | Codable DB row structs |
| S3 | BackgroundSyncAgent.swift | CREATE | Dual-write, offline queue |
| S4 | RealtimeSyncService.swift | CREATE | Real-time subscriptions |
| S5 | SpatialQueryService.swift | CREATE | PostGIS queries |
Schema Migration (NEW)
| # | File | Action | Purpose |
|---|------|--------|---------|
| G1 | AppSchemaV1.swift | CREATE | Baseline VersionedSchema snapshot for current shipped schema |
| G2 | AppSchemaV2.swift | CREATE | New schema with sync metadata and ownership changes |
| G3 | AppMigrationPlan.swift | CREATE | SchemaMigrationPlan for safe upgrades on existing installs |
Model Updates
| # | File | Action | Purpose |
|---|------|--------|---------|
| M1 | WatchlistModel.swift | MODIFY | Add syncStatus, localId, Codable |
| M2 | WatchlistPersistenceService.swift | MODIFY | Add dual-write calls |
| M3 | WatchlistManager.swift | MODIFY | Use UserSession.currentUserId, add sync hooks |
Home Feature (NEW)
| # | File | Action | Purpose |
|---|------|--------|---------|
| H1 | HomeSyncService.swift | CREATE | Pull/refresh Home reference datasets from Supabase with offline cache |
| H2 | HomePersistenceModels.swift | MODIFY | Add remote metadata fields (remoteId/updatedAt/syncStatus where needed) |
| H3 | HomeDataSeeder.swift | MODIFY | Keep bundle seeding as bootstrap fallback only |
| H4 | HomeManager.swift | MODIFY | Stale-while-revalidate loading (local first, background refresh) |
| H5 | HomeViewController.swift | MODIFY | Handle refresh/error/empty states for remote-backed Home data |
| H6 | WatchlistDomainModels.swift (LocationPreferences) | MODIFY | Namespace home location by guest/user and support adoption on login |
Identification Feature (NEW)
| # | File | Action | Purpose |
|---|------|--------|---------|
| I1 | IdentificationSyncService.swift | CREATE | Sync identification sessions/results/candidates/marks |
| I2 | IdentificationModels.swift | MODIFY | Add owner/sync metadata for guest-first + post-login adoption |
| I3 | IdentificationManager.swift | MODIFY | Remove random UUID ownership; use pending-owner + adopt-on-login |
| I4 | IdentificationViewController.swift | MODIFY | Scope history to current owner context (user or guest) |
| I5 | IdentificationSeeder.swift | MODIFY | Keep reference data seeding only (shape/field-mark dictionaries) |
---
3. Auth Flow (3 Paths → Supabase)
┌─────────────────────────────────────────────────────────────────┐
│                     AUTHENTICATION PATHS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐       │
│  │   Google    │    │  Email/Pass │    │   SignUp    │       │
│  │  Sign-In   │    │   Login     │    │  (Email)    │       │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘       │
│         │                  │                  │               │
│         └──────────────────┼──────────────────┘               │
│                            ↓                                   │
│                  ┌─────────────────────┐                      │
│                  │ SupabaseAuthService │                      │
│                  │  - signIn()         │                      │
│                  │  - signUp()         │                      │
│                  │  - signInGoogle()   │                      │
│                  │  - signOut()        │                      │
│                  └──────────┬──────────┘                      │
│                             ↓                                  │
│                  ┌─────────────────────┐                      │
│                  │   Get auth.uid()    │                      │
│                  └──────────┬──────────┘                      │
│                             ↓                                  │
│                  ┌─────────────────────┐                      │
│                  │   UserSession      │                      │
│                  │  .currentUserId     │ ← Supabase auth.uid  │
│                  │  .currentUser       │ ← User profile       │
│                  └──────────┬──────────┘                      │
│                             ↓                                  │
│                  ┌─────────────────────┐                      │
│                  │   UserSyncService   │                      │
│                  │  (upsert to users)  │                      │
│                  └──────────┬──────────┘                      │
│                             ↓                                  │
│                  Watchlist.owner_id                            │
│                  = currentUserId (or nil in guest mode)        │
└─────────────────────────────────────────────────────────────────┘
---
4. owner_id Wiring Specification
// UserSession.swift - ADD
class UserSession {
    static let shared = UserSession()
    
    var currentUserId: UUID? {
        // Returns Supabase auth UID
        SupabaseConfig.shared.client.auth.session.user.id
    }
    
    var currentUser: User? {
        // Returns full User with Supabase UUID
        getUser()
    }
}
// WatchlistManager.swift - CHANGE all hardcoded references
// BEFORE:
let ownerId = Watchlist.defaultOwnerId // Hardcoded UUID!
// AFTER:
let ownerId = UserSession.shared.currentUserId // nil when logged out
// WatchlistModel.swift - CHANGE default
// BEFORE:
static let defaultOwnerId = WatchlistConstants.defaultOwnerID // UUID
// AFTER:
var owner_id: UUID? // nil allowed for guest-created local records
var syncStatus: SyncStatus // includes .pendingOwner for guest-created records

// On login: adopt guest data
func adoptGuestWatchlists(to userId: UUID) async {
    // Set owner_id for all pending-owner local records and queue sync
}
---
5. Image Path Dual Storage
// ObservedBirdPhoto - STORE BOTH
@Model
final class ObservedBirdPhoto {
    var imagePath: String        // Local path (always valid)
    var storageUrl: String?      // Supabase Storage URL (after upload)
    var isUploaded: Bool = false
    
    // Convenience accessor
    var displayUrl: String {
        isUploaded ? (storageUrl ?? imagePath) : imagePath
    }
}
// BackgroundSyncAgent - Photo Upload Logic
private func syncPendingPhotos() async {
    for photo in pending {
        // 1. Upload to Supabase Storage
        let url = try await uploadToSupabase(photo.imagePath)
        
        // 2. Update fields (keep BOTH)
        photo.storageUrl = url
        photo.isUploaded = true
        
        // 3. Queue for Supabase DB sync
        await queueForSupabaseSync(photo)
    }
}
// On deletion
private func deletePhoto(_ photo: ObservedBirdPhoto) async {
    // 1. Delete from Supabase Storage (if uploaded)
    if photo.isUploaded, let url = photo.storageUrl {
        try await supabase.storage.from("photos").remove(path: extractPath(url))
    }
    
    // 2. Delete local file
    try? FileManager.default.removeItem(atPath: photo.imagePath)
}
---
6. Dual-Write Concurrency (@MainActor)
// BackgroundSyncAgent.swift
actor BackgroundSyncAgent {
    // Actor isolation ensures thread-safety
    
    func syncAll() async {
        // Runs on background thread
        await syncWatchlists()
        await syncEntries()
        await syncPhotos()
    }
}
// WatchlistPersistenceService.swift
@MainActor
class WatchlistPersistenceService {
    // UI calls - must run on main thread
    
    func create(...) async throws -> Watchlist {
        // 1. Save to SwiftData (main thread)
        let watchlist = try await localCreate(...)
        
        // 2. Fire-and-forget background sync (different thread)
        Task.detached(priority: .utility) {
            await BackgroundSyncAgent.shared.syncWatchlist(watchlist)
        }
        
        return watchlist
    }
}
// SceneDelegate.swift - Auth check
if let session = SupabaseAuthService.shared.restoreSessionFromKeychain() {
    // Valid session exists
    UserSession.shared.syncFromSupabaseSession()
    // Continue to main
} else {
    // No session - go to onboarding
}

// App startup also registers auth state listener
SupabaseAuthService.shared.observeAuthStateChanges()
// On token refresh/sign-in/sign-out:
// - update stored Keychain session
// - update UserSession
// - notify watchlist sync layer
---
7. Session + Guest Persistence Rules (MANDATORY)
// Privacy-first session persistence
// 1. Store Supabase session in iOS Keychain only
// 2. Restore session during app launch
// 3. Handle auth state changes (sign-in, refresh, sign-out) and keep UserSession in sync
//
// Guest behavior (logged out)
// 4. Allow local watchlist CRUD while owner_id is nil
// 5. Persist guest local data across app restarts
// 6. Skip remote sync while owner_id is nil (syncStatus = .pendingOwner)
//
// Login behavior
// 7. Adopt all .pendingOwner records: set owner_id = currentUserId, then enqueue sync
//
// Logout behavior
// 8. Clear local watchlist data on logout (user requirement)
// 9. Cancel sync queues/retries and realtime subscriptions
// 10. Clear UserSession and cached profile/session artifacts
// 11. Clear user-scoped Home + Identification data on logout
// 12. Keep reference seed flags; clear only user-scoped seed flags
---
8. Seeded Data Migration
// Migration script (one-time)
struct MigrationScript {
    static func run() async {
        // PRECONDITION: run only when an authenticated session exists
        guard let currentUserId = UserSession.shared.currentUserId else { return }

        // 1. Fetch all watchlists from SwiftData (exclude virtual My Watchlist UUID)
        let watchlists = try await fetchAllWatchlists()
        
        // 2. For each watchlist:
        //    - Create new UUID (Supabase style)
        //    - Store old UUID as localId
        //    - Set owner_id = currentUserId
        //    - Set syncStatus = .synced
        
        // 3. Same for entries, rules, shares, photos
        
        // 4. Upload all to Supabase
        
        // 5. Mark migration complete (UserDefaults flag)
    }
}
---
8.1 Critical Decisions + Migration Safety (MANDATORY BEFORE IMPLEMENTATION)
// A. SwiftData schema migration
// 1. All model changes (owner_id/syncStatus/localId/updatedAt) ship behind VersionedSchema + SchemaMigrationPlan
// 2. Existing installs must migrate on launch without data loss/crash
//
// B. MigrationDataPayload decision
// 3. MigrationDataPayload is NOT synced in V2 (local/cache only)
// 4. Keep it in schema for V2 compatibility; deprecation/removal considered only in a later schema version
//
// C. Reference-data boundary (do not sync ownership metadata)
// 5. BirdShape, BirdFieldMark, FieldMarkVariant remain local seeded reference data only
// 6. Identification sync payloads use String shape IDs (BirdShape.id / Bird.shape_id), not UUID
//
// D. Identification location persistence
// 7. Add `locationDisplayName: String?` to IdentificationSession for reconstructing UI after sync/reload
//
// E. Seeding flags + logout semantics
// 8. Reference flags NEVER cleared on logout: kBirdDatabaseSeeded_v1 and identification reference-seed completion
// 9. User-scoped flags cleared on logout: watchlist/home-user-data seed flags and per-user preference flags
//
// F. Virtual watchlist safety
// 10. Never sync WatchlistConstants.myWatchlistID (00000000-0000-0000-0000-000000000000); it is derived UI state
//
// G. Home data classification
// 11. Hotspot/HotspotSpeciesPresence/MigrationSession/TrajectoryPath/News are reference data (read-mostly)
// 12. CommunityObservation is user-authored and owner-scoped: add owner_id + syncStatus + guest adoption flow
// 13. Seeded community observations from home_data.json must be marked as `seeded/system` and excluded from upstream sync
//
// H. Serialization constraints
// 14. WatchlistRule.parameters_json remains raw String in SyncModels and Supabase row mapping
// 15. ObservedBirdPhoto.imagePath is filename-only; sync and deletion must resolve Documents/ObservedBirdPhotos/<filename>
//
// I. Keychain cleanup gate
// 16. Do not delete KeychainManager.swift until SupabaseAuthService storage path is confirmed and tested
---
8.2 Explicit SwiftData Migration Specification (MANDATORY)
// V1 -> V2 migration rules (AppSchemaV1/AppSchemaV2/AppMigrationPlan)
| Model | V2 Change | Migration Rule |
|-------|-----------|----------------|
| Watchlist | owner_id nullable + sync metadata | If logged in at migration: owner_id=currentUserId, else owner_id=nil and syncStatus=.pendingOwner |
| WatchlistEntry | sync metadata | localId=existing id, syncStatus=.pendingOwner when parent owner_id=nil |
| WatchlistRule | sync metadata | Keep parameters_json as raw String, do not decode into Dictionary |
| WatchlistShare | sync metadata | Preserve user_id and permission; set owner context from parent watchlist |
| ObservedBirdPhoto | sync metadata + storageUrl flags | imagePath remains filename; populate resolved absolute path at sync-time only |
| CommunityObservation | owner_id + sync metadata + sourceType | Seeded rows sourceType=system and excluded from upstream sync |
| IdentificationSession | owner_id + sync metadata + locationDisplayName | Preserve existing locationId; initialize locationDisplayName from cached map or nil-safe fallback |
| IdentificationResult | owner_id + sync metadata | Derive owner_id from parent session |
| IdentificationCandidate | sync metadata | Preserve rank/confidence; derive owner through result/session |
| MigrationDataPayload | unchanged for V2 | Keep local/cache only, no sync metadata in V2 |
| BirdShape/BirdFieldMark/FieldMarkVariant | unchanged | Remain seeded reference data; no owner/sync fields |
//
// Migration script deliverables
// 1. AppMigrationPlan.swift with stage-by-stage transformations above
// 2. Migration validation script for preloaded V1 stores
// 3. Post-migration integrity checks: relationships, owner assignment, pending-owner counts
---
8.3 Migration Rollback + Recovery Strategy (MANDATORY)
// 1. Before running V2 migration, create on-device backup copy of SwiftData sqlite + wal + shm files
// 2. If migration fails, restore backup and launch app in safe mode (read-only + retry prompt)
// 3. Emit structured error log with failed model/step for support diagnostics
// 4. Do not clear local data on migration failure; block sync until recovery succeeds
// 5. Add one-time `migrationFailed` flag to prevent migration loop crashes
---
8.4 Sync Error Handling + Conflict + Retry Strategy (MANDATORY)
// Error classes
// 1. Auth errors (401/invalid session)
// 2. Network/transient errors (timeouts, 5xx, offline)
// 3. Validation/permanent errors (4xx malformed payloads)
// 4. Conflict errors (same row updated on multiple devices)
//
// Retry policy
// 5. Exponential backoff with jitter: 2s, 5s, 15s, 30s, 60s (max 5 attempts)
// 6. After max attempts, move operation to dead-letter queue with user-visible retry action
//
// Conflict policy (multi-device)
// 7. Timestamp-based last-write-wins using server `updated_at` + client `updated_at`
// 8. Preserve tombstones for deletions so stale devices do not resurrect deleted records
// 9. Deterministic merge for candidates: stable rank order by confidence then created_at
//
// Token refresh during active sync
// 10. On 401: pause queue, refresh session once, replay pending batch with same idempotency keys
// 11. If refresh fails: keep local ops pending, mark sync as blocked-auth, route user to re-login
// 12. Resume queue automatically after successful re-auth
//
// Observability
// 13. Log sync lifecycle events with operationId/model/attempt/errorType for debugging
---
8.5 Sync Test Strategy (MANDATORY BEFORE SHIP)
// Unit tests
// 1. Row mapping tests for SyncModels (including parameters_json String and shape String IDs)
// 2. Conflict resolver tests (timestamp LWW + tombstone behavior)
//
// Migration tests
// 3. V1 -> V2 migration on real fixture stores with seeded and non-seeded states
// 4. Migration rollback path test (forced failure + backup restore)
//
// Integration tests
// 5. Offline create/update/delete then reconnect sync
// 6. Guest-create then login adoption for Watchlist/Home/Identification
// 7. Token expires mid-sync and refresh/replay succeeds
// 8. Multi-device concurrent edits resolved by timestamps
// 9. Logout clears user-scoped data but keeps reference data flags
//
// Regression gates
// 10. Build fails CI if migration tests or sync integration tests fail
---
9. Home Feature Persistence + Sync Plan
// Data ownership split
// 1. Global/reference data (not user-owned): Hotspot, HotspotSpeciesPresence, MigrationSession, TrajectoryPath, static news seed
// 2. User-scoped data: home location preference and user-authored community observations
// 3. Watchlist-derived cards remain computed from user-scoped watchlist state
//
// Sync strategy
// 4. Keep HomeDataSeeder for offline bootstrap and recovery only
// 5. Add HomeSyncService for delta pulls from Supabase (updated_at cursor/version)
// 6. In HomeManager, load local cache immediately, then refresh in background (stale-while-revalidate)
// 7. Keep Home usable in guest mode using local data and guest watchlist state
// 8. NewsService stays local-only (home_data.json) in this phase unless explicitly moved to remote later
// 9. Seeded community observations are local demo content (`seeded/system`) and must not sync upward
//
// Session + privacy behavior
// 10. Persist guest home preferences across restarts before login
// 11. On login, adopt guest-scoped Home preferences and guest community observations to currentUserId
// 12. On logout, clear user-scoped Home data/preferences; retain only global cache
//
// Integration boundary with Watchlist
// 13. HomeManager consumes watchlist data only through manager APIs (no direct auth logic in VC)
---
10. Identification Feature Persistence + Sync Plan
// Current gaps to resolve
// 1. IdentificationManager currently creates new sessions with random UUID() ownership; replace with owner-aware model
// 2. Identification history fetch currently pulls all completed sessions; scope by active owner context
//
// Ownership + guest model
// 3. Add owner_id (nullable) + syncStatus to IdentificationSession/Result/Candidate graph
// 4. Guest sessions persist locally with owner_id = nil and syncStatus = .pendingOwner
// 5. On login, adopt pending-owner sessions/results/candidates to currentUserId and queue sync
// 6. Add locationDisplayName to IdentificationSession so synced sessions can render location text without in-memory map
//
// Sync model
// 7. Add IdentificationSyncService + BackgroundSyncAgent hooks for session/result/candidate/field-mark rows
// 8. Use deterministic candidate rank ordering and last-write-wins metadata conflict policy
// 9. Shape references are String IDs (BirdShape.id / Bird.shape_id) and remain reference-data-only
//
// Session + privacy behavior
// 10. Keep identification history across restarts while logged out
// 11. On logout, clear local identification history and reset in-memory IdentificationManager state
---
11. Updated Implementation Sequence
Phase 0: Safety + Schema Foundations (Week 0)
├── 0.0 Prerequisite: fix existing SceneDelegate root-routing bug in current codebase
├── 0.1 Create AppSchemaV1.swift from current schema
├── 0.2 Define AppSchemaV2.swift with all new sync/ownership fields
├── 0.3 Implement AppMigrationPlan.swift and launch migration tests on existing local DB
├── 0.4 Freeze decisions for MigrationDataPayload (local-only in V2) and reference-data boundaries
├── 0.5 Add sync exclusion for WatchlistConstants.myWatchlistID
├── 0.6 Implement backup/restore rollback path for migration failures
└── 0.7 Add migration integrity checks and failure telemetry
Phase 1: Auth Replacement (Week 1)
├── 1.1 Add UUID to User.swift
├── 1.2 Create SupabaseClient.swift
├── 1.3 Create SupabaseAuthService.swift (replace KeychainManager)
├── 1.3a Persist Supabase session in iOS Keychain (privacy-first)
├── 1.3b Add auth state observer (sign-in/refresh/sign-out)
├── 1.4 Create SyncModels.swift
├── 1.5 Modify UserSession.swift (add currentUserId)
├── 1.6 Modify LoginViewController.swift (Supabase auth)
├── 1.7 Modify SignUpViewController.swift (Supabase auth)
├── 1.8 Modify StartViewController.swift (Supabase Google)
├── 1.9 Modify SceneDelegate.swift (restore session on app launch)
└── 1.10 Create UserSyncService.swift
Phase 2: Dual-Write Sync (Week 2)
├── 2.1 Update WatchlistModel.swift (syncStatus, localId, Codable)
├── 2.2 Update WatchlistEntry, WatchlistRule, etc.
├── 2.2a Add pending-owner local state for guest-created records
├── 2.2b Keep WatchlistRule.parameters_json as raw String in SyncModels
├── 2.3 Create BackgroundSyncAgent.swift
├── 2.4 Modify WatchlistPersistenceService.swift
├── 2.5 Modify WatchlistManager.swift (no hardcoded owner fallback)
├── 2.5a Adopt guest records after login
├── 2.6 Add retry queue, dead-letter handling, and token-refresh-aware replay
├── 2.7 Run migration script
└── 2.8 Test dual-write
Phase 3: Photo Storage + Real-time (Week 3)
├── 3.1 Create "photos" bucket
├── 3.2 Update BackgroundSyncAgent for dual storage
├── 3.3 Resolve filename to full Documents/ObservedBirdPhotos path before upload/delete
├── 3.4 Create RealtimeSyncService.swift
├── 3.5 Add subscription in WatchlistManager
└── 3.6 Handle conflicts
Phase 4: PostGIS + Background Tasks (Week 4)
├── 4.1 Create SpatialQueryService.swift
├── 4.2 Register BGTaskScheduler
└── 4.3 Implement background sync
Phase 5: Polish (Week 5)
├── 5.1 Error handling, retry, progress UI
├── 5.2 Logout clear-data flow + regression tests
├── 5.3 Seed-flag policy tests (reference flags persist, user flags clear)
└── 5.4 Multi-device conflict tests using timestamp LWW policy
Phase 6: Home Feature Integration (Week 6)
├── 6.1 Create HomeSyncService.swift
├── 6.2 Update HomePersistenceModels.swift with remote metadata fields
├── 6.3 Modify HomeDataSeeder.swift to bootstrap-only fallback behavior
├── 6.4 Modify HomeManager.swift to local-first + background refresh
├── 6.5 Modify HomeViewController.swift for loading/refresh/error states
├── 6.6 Namespace LocationPreferences by guest/user and adopt on login
├── 6.7 Add owner-scoped CommunityObservation sync/adoption behavior
└── 6.8 Add Home logout cleanup and regression tests
Phase 7: Identification Integration (Week 7)
├── 7.1 Modify IdentificationModels.swift for owner-aware sync metadata
├── 7.2 Modify IdentificationManager.swift to remove random UUID ownership
├── 7.3 Add pending-owner behavior for guest identification sessions
├── 7.4 Modify IdentificationViewController.swift to scope history by owner context
├── 7.5 Create IdentificationSyncService.swift and queue hooks
├── 7.6 Persist locationDisplayName in IdentificationSession and sync payload
├── 7.7 Add login adoption for pending-owner identification sessions
└── 7.8 Add identification logout cleanup + migration/regression tests
---
12. Files Summary
| Category | Create | Modify |
|----------|--------|--------|
| Auth | SupabaseAuthService.swift, UserSyncService.swift | User.swift, UserSession.swift, LoginVC, SignUpVC, StartVC, SceneDelegate |
| Core | SupabaseClient.swift, SyncModels.swift | - |
| Schema | AppSchemaV1.swift, AppSchemaV2.swift, AppMigrationPlan.swift | WatchlistManager.swift |
| Sync | BackgroundSyncAgent.swift, RealtimeSyncService.swift, SpatialQueryService.swift | WatchlistModel.swift, WatchlistPersistenceService.swift, WatchlistManager.swift |
| Home | HomeSyncService.swift | HomePersistenceModels.swift, HomeDataSeeder.swift, HomeManager.swift, HomeViewController.swift, WatchlistDomainModels.swift (LocationPreferences) |
| Identification | IdentificationSyncService.swift | IdentificationModels.swift, IdentificationManager.swift, IdentificationViewController.swift, IdentificationSeeder.swift |
| Cleanup | - | Defer KeychainManager.swift deletion until SupabaseAuthService storage is verified in integration tests |
---
Ready to proceed? Say "Go" and I'll implement Phase 1 (Auth Replacement).
