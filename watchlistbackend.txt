Minimal Plan: Watchlist + Supabase + PostGIS + Realtime

================================================================================
WHAT'S ALREADY DONE ✅
================================================================================

| Component | Status |
|-----------|--------|
| WatchlistModel.owner_id | ✅ Added (nullable UUID) |
| SyncModels.swift (SyncStatus enum) | ✅ Created |
| bindWatchlistsToCurrentUser() | ✅ In persistence service |
| Login/Signup integration | ✅ Calls bindCurrentUserOwnership |

================================================================================
PHASE 0: SUPABASE CLIENT FOUNDATION (Priority: HIGH - DO FIRST)
================================================================================

| # | File | Action |
|---|------|--------|
| 0.1 | SupabaseClient.swift | CREATE - central HTTP client wrapper |
| | | - Extends existing SupabaseAuthService |
| | | - Generic request<T> method for any endpoint |
| | | - Token refresh handling |
| | | - Error normalization |

SupabaseClient Responsibilities:
- Single source of truth for Supabase HTTP communication
- Request/Response logging (debug builds)
- Automatic retry for transient failures
- Centralized error mapping

================================================================================
PHASE 1: DATA MODELS + SYNC STATUS (Priority: HIGH)
================================================================================

| # | File | Action |
|---|------|--------|
| 1.1 | WatchlistModel.swift | Add fields: |
| | | - `syncStatus: SyncStatus` |
| | | - `lastSyncedAt: Date?` |
| | | - `serverRowVersion: Int` (default 0) |
| 1.2 | WatchlistEntry.swift | Add fields: |
| | | - `syncStatus: SyncStatus` |
| | | - `lastSyncedAt: Date?` |
| | | - `serverRowVersion: Int` |
| 1.3 | WatchlistRule.swift | Add fields: |
| | | - `syncStatus: SyncStatus` |
| | | - `lastSyncedAt: Date?` |
| | | - `serverRowVersion: Int` |
| 1.4 | ObservedBirdPhoto.swift | Add fields: |
| | | - `syncStatus: SyncStatus` |
| | | - `storageUrl: String?` |
| | | - `isUploaded: Bool` (default false) |
| | | - `lastSyncedAt: Date?` |
| | | NOTE: Model currently missing these - Row struct has them |

NOTE: `localId` removed from plan - UUID is globally unique, redundant.
NOTE: `serverRowVersion` enables optimistic locking for conflict detection.

================================================================================
PHASE 2: SUPABASE SCHEMA (DDL)
================================================================================

Create SupabaseSchema.swift with SQL DDL for:
- users table
- watchlists table (with owner_id, sync_status, row_version, timestamps)
- watchlist_entries table
- watchlist_rules table
- observed_bird_photos table
- Enable PostGIS extension
- Row Level Security (RLS) policies

NOTE: Also update Row structs in SyncModels.swift to include:
- rowVersion: Int
- lastSyncedAt: Date?

PostgreSQL Schema:

-- Enable PostGIS
create extension if not exists postgis;

-- Bird table (referenced by watchlist_entries)
create table bird (
    id uuid primary key,
    common_name text not null,
    scientific_name text,
    static_image_name text,
    family text,
    order_name text,
    description_text text,
    conservation_status text,
    rarity_level text,
    migration_strategy text,
    hemisphere text,
    valid_locations text[],
    valid_months int[],
    shape_id text,
    size_category int,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- Hotspot table (for PostGIS functions)
create table hotspot (
    id uuid primary key,
    name text not null,
    locality text,
    lat double precision,
    lon double precision,
    location geography(point, 4326) generated always as (
        st_geogfromtext('point(' || lon || ' ' || lat || ')')
    ) stored,
    image_name text,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- Users table
create table users (
    id uuid primary key references auth.users,
    name text not null,
    gender text,
    email text not null,
    profile_photo text,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- Watchlists table
create table watchlists (
    id uuid primary key,
    owner_id uuid references auth.users,
    type text,
    title text,
    location text,
    location_display_name text,
    start_date date,
    end_date date,
    observed_count int default 0,
    species_count int default 0,
    cover_image_path text,
    species_rule_enabled bool default false,
    species_rule_shape_id text,
    location_rule_enabled bool default false,
    location_rule_lat double precision,
    location_rule_lon double precision,
    location_rule_radius_km double precision,
    location_rule_display_name text,
    date_rule_enabled bool default false,
    date_rule_start_date date,
    date_rule_end_date date,
    sync_status text default 'pendingCreate',
    row_version int default 1,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- Watchlist entries table
create table watchlist_entries (
    id uuid primary key,
    watchlist_id uuid references watchlists(id) on delete cascade,
    bird_id uuid references bird(id),
    nickname text,
    status text,
    notes text,
    added_date timestamptz default now(),
    observation_date timestamptz,
    to_observe_start_date timestamptz,
    to_observe_end_date timestamptz,
    observed_by text,
    lat double precision,
    lon double precision,
    location_display_name text,
    priority int default 0,
    notify_upcoming bool default false,
    target_date_range text,
    sync_status text default 'pendingCreate',
    row_version int default 1,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- Watchlist rules table
create table watchlist_rules (
    id uuid primary key,
    watchlist_id uuid references watchlists(id) on delete cascade,
    rule_type text not null,
    parameters_json text,
    is_active bool default true,
    priority int default 0,
    sync_status text default 'pendingCreate',
    row_version int default 1,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- Observed bird photos table
create table observed_bird_photos (
    id uuid primary key,
    watchlist_entry_id uuid references watchlist_entries(id) on delete cascade,
    image_path text not null,
    storage_url text,
    is_uploaded bool default false,
    captured_at timestamptz,
    uploaded_at timestamptz,
    sync_status text default 'pendingCreate',
    row_version int default 1,
    last_synced_at timestamptz,
    deleted_at timestamptz,
    created_at timestamptz default now(),
    updated_at timestamptz
);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on all tables
alter table watchlists enable row level security;
alter table watchlist_entries enable row level security;
alter table watchlist_rules enable row level security;
alter table observed_bird_photos enable row level security;

-- Watchlists: Users can only see their own watchlists (or shared ones)
create policy "Users can view own watchlists" on watchlists
    for select using (owner_id = auth.uid());

create policy "Users can view shared watchlists" on watchlists
    for select using (
        id in (select watchlist_id from watchlist_shares where user_id = auth.uid())
    );

create policy "Users can insert own watchlists" on watchlists
    for insert with check (owner_id = auth.uid());

create policy "Users can update own watchlists" on watchlists
    for update using (owner_id = auth.uid())
    with check (owner_id = auth.uid());

create policy "Users can delete own watchlists" on watchlists
    for delete using (owner_id = auth.uid());

-- Watchlist entries: Inherit access from parent watchlist
create policy "Users can manage entries in own watchlists" on watchlist_entries
    for all using (
        watchlist_id in (select id from watchlists where owner_id = auth.uid())
    );

-- Watchlist rules: Inherit access from parent watchlist
create policy "Users can manage rules in own watchlists" on watchlist_rules
    for all using (
        watchlist_id in (select id from watchlists where owner_id = auth.uid())
    );

-- Observed bird photos: Inherit access from parent entry
create policy "Users can manage photos in own entries" on observed_bird_photos
    for all using (
        watchlist_entry_id in (
            select we.id from watchlist_entries we
            join watchlists w on we.watchlist_id = w.id
            where w.owner_id = auth.uid()
        )
    );

-- PostGIS Functions

-- Hotspots near location
create or replace function hotspots_near(
    lat double precision,
    lon double precision, 
    radius_km double precision
) returns setof hotspot as $$
    select * from hotspot
    where st_dwithin(
        st_geogfromtext('point(' || lon || ' ' || lat || ')'),
        hotspot.location,
        radius_km * 1000
    );
$$ language sql;

-- Birds (from entries) near location
create or replace function birds_near(
    lat double precision,
    lon double precision,
    radius_km double precision
) returns table(...) as $$
    select distinct b.* from watchlist_entry we
    join bird b on we.bird_id = b.id
    where st_dwithin(
        st_geogfromtext('point(' || we.lon || ' ' || we.lat || ')'),
        st_geogfromtext('point(' || lon || ' ' || lat || ')'),
        radius_km * 1000
    );
$$ language sql;

================================================================================
PHASE 3: BACKGROUND SYNC AGENT
================================================================================

| # | File | Action |
|---|------|--------|
| 3.1 | SyncRetryPolicy.swift | CREATE - retry configuration |
| 3.2 | BackgroundSyncAgent.swift | CREATE - dual-write, offline queue |
| 3.3 | WatchlistPersistenceService.swift | Add sync hooks on CRUD |

--------------------------------------------------------------------------------
SYNC RETRY POLICY (SyncRetryPolicy.swift)
--------------------------------------------------------------------------------

struct SyncRetryPolicy {
    static let maxRetries: Int = 3
    static let initialDelay: TimeInterval = 1.0      // 1 second
    static let maxDelay: TimeInterval = 60.0         // 60 seconds
    static let backoffMultiplier: Double = 2.0       // Exponential backoff
    
    static func delay(for attempt: Int) -> TimeInterval {
        let delay = initialDelay * pow(backoffMultiplier, Double(attempt))
        return min(delay, maxDelay)
    }
    
    static func shouldRetry(error: Error, attempt: Int) -> Bool {
        guard attempt < maxRetries else { return false }
        
        // Retry on network errors, 5xx, rate limits
        if let urlError = error as? URLError {
            return urlError.code == .timedOut ||
                   urlError.code == .notConnectedToInternet ||
                   urlError.code == .networkConnectionLost
        }
        return true  // Retry most errors, mark failed after max attempts
    }
}

--------------------------------------------------------------------------------
BACKGROUND SYNC AGENT SPECIFICATION
--------------------------------------------------------------------------------

class BackgroundSyncAgent: ObservableObject {
    @Published var isSyncing: Bool = false
    @Published var pendingOperations: Int = 0
    
    private var syncQueue: [SyncOperation] = []
    private var retryAttempts: [UUID: Int] = [:]
    
    // SYNC ORDER (CRITICAL):
    // 1. Watchlists (parents) → sync first
    // 2. WatchlistEntries (children) → sync after parent succeeds
    // 3. WatchlistRules (children) → sync after parent succeeds
    // 4. ObservedBirdPhotos (grandchildren) → sync AFTER entry sync completes
    
    // INCREMENTAL SYNC:
    // - Pull: SELECT * FROM watchlists WHERE updated_at > :lastSyncedAt
    // - Push: Only items with syncStatus != .synced
    
    // CONFLICT RESOLUTION (using row_version):
    // - On push: WHERE row_version = :localVersion
    // - If 0 rows affected → conflict detected
    // - Server wins for now (single device assumption)
    // - Update local with server data, set syncStatus = .synced
}

enum SyncOperation: Identifiable {
    case createWatchlist(UUID)
    case updateWatchlist(UUID)
    case deleteWatchlist(UUID)
    case createEntry(UUID)
    case updateEntry(UUID)
    case deleteEntry(UUID)
    case uploadPhoto(UUID)
    case deletePhoto(UUID)
    
    var id: UUID { ... }
    var priority: Int { ... }  // Lower = higher priority
}

================================================================================
PHASE 4: PHOTO UPLOAD (DUAL STORAGE)
================================================================================

| # | File | Action |
|---|------|--------|
| 4.1 | SupabaseStorageService.swift | CREATE - upload to Supabase Storage |
| 4.2 | BackgroundSyncAgent | Add photo upload logic (depends on entry sync) |

--------------------------------------------------------------------------------
PHOTO SYNC ORDERING (CRITICAL)
--------------------------------------------------------------------------------

Photos MUST sync AFTER their parent WatchlistEntry is synced:

┌─────────────────────────────────────────────────────────────────┐
│ SYNC SEQUENCE:                                                  │
│                                                                 │
│  1. Watchlist.sync()     → success → syncStatus = .synced      │
│  2. Entry.sync()         → success → syncStatus = .synced      │
│  3. Photo.upload()       → success → isUploaded = true         │
│     Photo.sync()         → success → syncStatus = .synced      │
│                                                                 │
│ IF ENTRY SYNC FAILS:                                           │
│  - Photo stays pending (cannot sync orphan photo)              │
│  - Retry entry, then photo                                     │
│                                                                 │
│ IF PHOTO UPLOAD FAILS:                                         │
│  - Entry is already synced (no rollback needed)                │
│  - Photo retries independently with backoff                    │
│  - Local image still accessible, just not in cloud             │
└─────────────────────────────────────────────────────────────────┘

--------------------------------------------------------------------------------
SUPABASE STORAGE SERVICE SPECIFICATION
--------------------------------------------------------------------------------

class SupabaseStorageService {
    // Bucket: "watchlist-photos"
    
    func uploadPhoto(
        localPath: String,
        entryId: UUID,
        photoId: UUID
    ) async throws -> String  // Returns storage URL
    
    func deletePhoto(storageUrl: String) async throws
    
    func generatePublicUrl(path: String) -> URL
}

// Storage bucket structure:
// watchlist-photos/
//   └── {entryId}/
//       └── {photoId}.jpg

================================================================================
PHASE 5: REALTIME SYNC
================================================================================

| # | File | Action |
|---|------|--------|
| 5.1 | RealtimeSyncService.swift | CREATE - Supabase realtime subscriptions |
| 5.2 | WatchlistManager | Subscribe on launch |

================================================================================
PHASE 6: POSTGIS
================================================================================

| # | File | Action |
|---|------|--------|
| 6.1 | SpatialQueryService.swift | CREATE - queries for: |
| | | a) hotspots_near(lat, lon, radius_km) |
| | | b) birds_near(lat, lon, radius_km) |

================================================================================
KEY IMPLEMENTATION NOTES
================================================================================

1. SYNC STATUS FLOW:
   - Local create → pendingCreate → sync → synced
   - Guest create → pendingOwner → login → adopt → pendingCreate
   - Update → pendingUpdate → sync → synced
   - Delete → pendingDelete → sync → SET deleted_at = now() (tombstone)

2. INCREMENTAL SYNC (using lastSyncedAt):
   - First sync: Pull all, push pending
   - Subsequent: SELECT * WHERE updated_at > :lastSyncedAt
   - Server returns its current timestamp; client saves that for next pull
   - IMPORTANT: Always use server timestamp, never device clock

3. OPTIMISTIC LOCKING (using serverRowVersion):
   - Local row_version = server row_version at last sync
   - On update: UPDATE ... WHERE row_version = :localVersion
   - If affected_rows = 0 → conflict (server was updated)
   - Resolution: Server wins (single device for now), update local

4. ERROR HANDLING & RETRY:
   - 3 max retries with exponential backoff (1s, 2s, 4s)
   - Network errors → retry
   - 4xx errors (except 429) → mark failed, don't retry
   - 5xx errors → retry with backoff
   - After max retries → syncStatus = .failed, show in UI

5. PHOTO SYNC IS ASYNC:
   - Photos don't block entry sync
   - Upload happens after entry is synced
   - Failed uploads don't affect entry visibility

6. WHY SKIP MIGRATION:
   - App is still in development
   - On first launch with new schema, clear watchlists and re-seed
   - Users start fresh with sync-enabled storage
   - Can add migration later if needed for production

7. SKIP FOR NOW:
   - AppSchemaV1/V2 migration
   - Complex conflict resolution (single device initially)
   - Background tasks (foreground sync is fine)
   - Home/Identification features

8. SERVER TIMESTAMP FOR SYNC (CRITICAL - CLOCK SKEW FIX):
   - Pull endpoint returns { records: [...], serverTimestamp: "2024-..." }
   - Client saves serverTimestamp locally as lastSyncedAt
   - NEVER use device clock for lastSyncedAt - prevents missed updates due to clock skew

9. TOMBSTONE HANDLING (SOFT DELETE):
   - Delete → SET deleted_at = now(), NOT physical delete
   - Pull: WHERE updated_at > :lastSyncedAt (includes tombstones)
   - Client: If deleted_at != null, delete local record
   - Cleanup: Hard delete tombstones older than 30 days (optional server job)

================================================================================
IMPLEMENTATION ORDER (RECOMMENDED)
================================================================================

Week 1:
  ✅ Phase 0: SupabaseClient (already have AuthService, extend it)
  ✅ Phase 1: Add sync fields to models
  
Week 2:
  ✅ Phase 2: Run DDL in Supabase dashboard, verify RLS
  
Week 3:
  ✅ Phase 3: BackgroundSyncAgent + retry policy
  
Week 4:
  ✅ Phase 4: Photo upload
  ✅ Phase 5: Realtime subscriptions
  
Week 5:
  ✅ Phase 6: PostGIS queries
  ✅ Testing & edge cases
